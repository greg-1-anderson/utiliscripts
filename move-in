#!/bin/bash

#
# Barge in to a new system and make it mine.
#
#	+ Insures the machine has a public / private key pair
#	  stored in a location where it will be backed up.
#
#	+ Pulls down utiliscripts and adds them to the PATH.
#
# + Installs Drush, Sublime Text and other useful tools
#   that I use.
#
# + Sets up bash settings and other system preferences.
#
# Note that it is safe to move-in to machines with no
# GUI (graphic tool configuration skipped if X not available),
# and it is safe to run move-in multiple times (e.g. to update
# configuration when move-in script is modified).
#
# Good follow-up commands include:
#
#	install-components
#	repair-ubuntu
#
SELF_DIRNAME="`dirname -- "$0"`"


# Don't allow this as root unless you have logged in as root.
# I don't know that I recommend running this as root, but neither do I prevent it.
if [ "$USER" == "root" ] && [ $HOME != "/root" ]
then
	echo "Do not run this script via sudo root"
  exit 1
fi

# Default location to pull installation data from.  Before running this script,
# define:
#
#     export INSTALLATION_DATA_REPO=user@my.server.com:my_installdata.git

[ -z "$INSTALLATION_DATA" ] && export INSTALLATION_DATA=$HOME/local/installdata
if [ -z "$INSTALLATION_DATA_REPO" ] ; then
  if [ "$USER" == "ga" ]
  then
    export INSTALLATION_DATA_REPO=ga@vps.greenknowe.org:installdata.git
  fi
fi


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  G E T   I N S T A L L   D A T A
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check install data..."

# If we do not already have the installation data, then get it with git

if [ ! -d $INSTALLATION_DATA ] && [ -n "$INSTALLATION_DATA_REPO" ] ; then

  (
    cd $(dirname $INSTALLATION_DATA)
    git clone $INSTALLATION_DATA_REPO

  )

fi

if [ -f $INSTALLATION_DATA/moveinrc ] ; then
  source $INSTALLATION_DATA/moveinrc
fi

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  S E T   D E F A U L T   L O C A T I O N S
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


# Set up some default locations
[ -z "$UTILISCRIPTS" ]            && export UTILISCRIPTS=$HOME/local/utiliscripts
[ -z "$CONFIG" ]                  && export CONFIG=$HOME/local/config
[ -z "$SSH_KEY_ARCHIVE" ]         && export SSH_KEY_ARCHIVE=$INSTALLATION_DATA/ssh_key_archive
[ -z "$DESKTOP_BACKGROUND_DIR" ]  && export DESKTOP_BACKGROUND_DIR=$INSTALLATION_DATA/DesktopBackgrounds

# Location of per-user repositories
if [ -z "$CONFIG_REPO" ] ; then
  if [ "$USER" == "ga" ]
  then
    export CONFIG_REPO=git@vps.greenknowe.org:config.git
  fi
fi


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  I N S U R E   S S H   K E Y   P A I R S   A R E   S E T   U P
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check ssh keys..."

host=`hostname -s`
keytype=rsa

mkdir -p $HOME/.ssh

archive_key="$SSH_KEY_ARCHIVE/${host}_id_rsa"
if [ -f "${archive_key%rsa}"dsa ]
then
	archive_key="${archive_key%rsa}"dsa
  keytype=dsa
fi

# If we do not have a public/private key pair for this machine, then generate or restore one
if [ ! -f "$HOME/.ssh/id_$keytype" ]
then
	if [ -f "$archive_key" ] && [ -f "${archive_key}.pub" ]
  then
    echo "Restoring public / private key pair for $host"
      cp -f "$archive_key" "$HOME/.ssh/id_${keytype}"
      cp -f "${archive_key}.pub" "$HOME/.ssh/id_${keytype}.pub"
  else
		echo "Generating a public / private key pair for this system; please protect it with a password."
		ssh-keygen -t $keytype -f $HOME/.ssh/id_$keytype
  fi
fi

if [ -f "$HOME/.ssh/id_$keytype.pub" ] ; then
	echo "ssh key fingerprint for public key:"
	ssh-keygen -lf "$HOME/.ssh/id_$keytype.pub"
fi

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  A R C H I V E   K E Y   P A I R S
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check ssh key archive..."

CREATE_KEY_ARCHIVE=false
if [ ! -d "$(dirname $SSH_KEY_ARCHIVE)" ]
then
  CREATE_KEY_ARCHIVE=true
fi
mkdir -p $SSH_KEY_ARCHIVE

# If we have an archive of the public / private key pair for this machine, make sure it is accurate.
# If the key has not been archived yet, then archive it.
if [ -f "$archive_key" ] && [ -f "${archive_key}.pub" ]
then
  diff -q "$HOME/.ssh/id_${keytype}" "$archive_key"
  if [ $? != 0 ]
  then
    echo "WARNING: The archived key for $host is different than the current public / private key pair."
    echo "Remove one of the following pairs, then run this script again to fix:"
    echo "        rm \"$archive_key\" \"${archive_key}.pub\""
    echo " - OR -"
    echo "        rm \"$HOME/.ssh/id_$keytype\" \"$HOME/.ssh/id_${keytype}.pub\""
    exit 1
  else
    echo "# Public and private key already archived as ${archive_key##*/}"
  fi
else
  echo "# Archiving public / private key pair for $host..."
  cp -f "$HOME/.ssh/id_${keytype}" "$archive_key"
  cp -f "$HOME/.ssh/id_${keytype}.pub" "${archive_key}.pub"

  # Try to give the private key a new password, using empty for
  # the current password.  If this works, then balk.
  ssh-keygen -p -P "" -N "empty_passwords_are_bad" -f "$archive_key" > /dev/null 2>&1
  if [ $? == 0 ]
  then
    echo "WARNING: The password for id_${keytype} for $host is empty; private key REMOVED from archive."
    rm -f "$archive_key"
  else
    if [ -d "$INSTALLATION_DATA/.git" ] ; then
      (
        cd $SSH_KEY_ARCHIVE
        git add .
        git commit -m "Add new keypair for ${host}"
        git push
      )
    fi
  fi
fi

if $CREATE_KEY_ARCHIVE
then
  cp $SELF_DIRNAME/example.moveinrc $(dirname $SSH_KEY_ARCHIVE)/moveinrc
  (
    cd $(dirname $SSH_KEY_ARCHIVE)
    git init
    git add .
    git commit -m "Automatically create an installdata project to store key pairs in"
  )
fi

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  G E T   C O N F I G
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check config..."

# If we do not already have the config project, then get it with git

if [ ! -d $CONFIG ] && [ -n "$CONFIG_REPO" ] ; then

  (
    mkdir -p $(dirname $CONFIG)
    cd $(dirname $CONFIG)
    git clone $CONFIG_REPO
  )

fi

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  G E T   U T I L I S C R I P T S
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check utiliscripts..."

# If we do not already have utiliscripts, then get them with git

if [ ! -d $UTILISCRIPTS ] ; then

  (
    mkdir -p $(dirname $UTILISCRIPTS)
    cd $(dirname $UTILISCRIPTS)
    # read+write if "utiliscripts" is in $MAINTAINER, read-only otherwise
    if [ "${MAINTAINER}" != "${MAINTAINER/utiliscripts/}" ]
    then
      git clone git@github.com:greg-1-anderson/utiliscripts.git
      if [ $? <> 0 ]
      then
        echo "Could not clone a r/w copy of utiliscripts; cloning a r/o copy instead."
      fi
    fi

    if [ ! -d $UTILISCRIPTS ] ; then
      git clone git://github.com/greg-1-anderson/utiliscripts.git
    fi
  )

fi

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  G E T   D R U S H
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check drush..."

# If we do not already have drush, then get the master branch with git

DRUSH=
if [ -n "$DRUPALORG_USERNAME" ] && [ "${MAINTAINER}" != "${MAINTAINER/drush/}" ]
then
  DRUSH="$(which drush)"
  drush_version=$(drush status version --pipe)
  if [ "${drush_version%.*}" -lt 5 ]
  then
    DRUSH=
  fi
fi

if [ -z "$DRUSH" ] && [ ! -d  $HOME/local/drupal/drush ] ; then

  (
    mkdir -p $HOME/local/drupal
    cd $HOME/local/drupal
    # read+write if "drush" is in $MAINTAINER, read-only otherwise
    if [ -n "$DRUPALORG_USERNAME" ] && [ "${MAINTAINER}" != "${MAINTAINER/drush/}" ]
    then
      git clone --branch master ${DRUPALORG_USERNAME}@git.drupal.org:project/drush.git
      if [ ! -d drush ]
      then
      	echo "Could not clone a r/w copy of drush; cloning a r/o copy instead."
      fi
    fi

    if [ ! -d drush ] ; then
      git clone --branch master http://git.drupal.org/project/drush.git
    fi
  )
fi

if [ -z "$DRUSH" ] && [ -d  $HOME/local/drupal/drush ]
then
  DRUSH=$HOME/local/drupal/drush/drush
fi

echo "# Check drush extensions..."

DRUSH_EXTENSIONS=$HOME/local/drupal/drush_extensions
mkdir -p $DRUSH_EXTENSIONS

for drush_extension in \
    drush_sup \
    drush_iq \
    drush_extras \
    dbtng_migrator \
    registry_rebuild \
    sublime_completion \
    grn-6.x \
    module_builder \
    drush_deploy \
    cacheaudit \
  ; do

	extension_shortname=$(echo $drush_extension | sed -e 's|-[0-9]*\.x-*[0-9]*\.*[0-9x]*$||');
  extension_destination=$DRUSH_EXTENSIONS/$extension_shortname
  if [ ! -d "$extension_destination" ] ; then
		(
			cd $DRUSH_EXTENSIONS
      # read+write if "extension_shortname" is in $MAINTAINER, read-only otherwise
      if [ -n "$DRUPALORG_USERNAME" ] && [ "${MAINTAINER}" != "${MAINTAINER/$extension_shortname/}" ]
      then
        # Figure out what which branch to select (e.g. --branch 7.x-2.x)
        branch=$(drush pm-releases drush_iq | grep '\-dev' | head -n 1 | sed -e 's|^ *||' -e 's|-dev.*||')
        if [ -z "$branch" ]
        then
          echo "Could not determine default branch for $extension_shortname"
        else
          git clone --recursive --branch "$branch" ${DRUPALORG_USERNAME}@git.drupal.org:project/$extension_shortname.git
          if [ ! -d $extension_shortname ]
          then
            echo "Could not clone a r/w copy of $extension_shortname; cloning a r/o copy instead."
          fi
        fi
      fi
			if [ ! -d "$extension_destination" ] ; then
        $DRUSH --yes pm-download $drush_extension --destination="$extension_destination"
      fi
		)
	fi

done

# Also copy in some of the example drush extensions from the drush/examples folder

for example_extensions in sync_enable.drush.inc sync_via_http.drush.inc ; do

	if [ ! -f "$HOME/local/drupal/drush_extensions/$example_extensions" ] ; then

		cp "$HOME/local/drupal/drush/examples/$example_extensions" $HOME/local/drupal/drush_extensions

	fi
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  G E T   S U B L I M E
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if [ -n "$DISPLAY" ] ; then

  echo "# Check sublime..."

  s=`which sublime_text`
  if [ -z "$s" ] && [ ! -d "$HOME/local/sublime-text-2" ]; then

  	sublime_url=`curl http://www.sublimetext.com/2 2>/dev/null | grep 'a href.*Linux 32' | sed -e 's/.*href="\([^"]*\).*/\1/'`
  	if [ -z "$sublime_url" ] ; then
  		sublime_url="http://c758482.r82.cf2.rackcdn.com/Sublime Text 2.0.tar.bz2"
  	fi
  	sublime_file="${sublime_url##*/}"

  	mkdir -p $HOME/tmp
  	mkdir -p $HOME/local

  	wget -O "$HOME/tmp/$sublime_file" "$sublime_url"
  	tar -xjvf "$HOME/tmp/$sublime_file" -C $HOME/local

  	mv "$HOME/local/Sublime Text 2" $HOME/local/sublime-text-2
  fi

fi

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  S E T   U P   B A S H   A N D   D R U S H   E N V I R O N M E N T S
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

echo "# Check bash and drush environments..."

#
# Get rid of the old .bash_customizations file if it exists
#
if [ -f $HOME/.bash_customizations ]; then
	rm $HOME/.bash_customizations
fi

# Put in uniform drushrc.php

mkdir -p $HOME/.drush

if [ -f  $HOME/.drush/drushrc.php ]
then
  # If the old drushrc.php is a symbolic link, then get rid of it.
  drushrctype="`stat --printf='%F' $HOME/.drush/drushrc.php`"
  if [ "$drushrctype" == "symbolic link" ]
  then
    rm -f $HOME/.drush/drushrc.php
  else
    # If the old drushrc.php is not a symbolic link, then move it
    # to the new config location
    if [ ! -f $CONFIG/drushrc.php ]
    then
      mkdir -p $CONFIG
      mv -f "$(dirname $DRUSH)/examples/example.drushrc.php" "$CONFIG/drushrc.php"
    fi
  fi
else
  # If there was no drushrc config file in either location, then copy the
  # example drushrc.php file to provide a starting point.
  if [ ! -f $CONFIG/drushrc.php ]
  then
    mkdir -p $CONFIG
    cp -f "$(dirname $DRUSH)/examples/example.drushrc.php" "$CONFIG/drushrc.php"
  fi
fi

# At this point, there should not be a drushrc.php file in the
# $HOME directory unless both $HOME/.drush and the config location
# both had drushrc.php files.  If there is none, then make an empty file.
if [ ! -f  $HOME/.drush/drushrc.php ]
then
  echo << __EOT__ > $HOME/.drush/drushrc.php
<?php

__EOT__
fi

# At this point we will always have something in the .drush directory.
# Add our template to the beginning of whatever was there, unless it
# has already been added.
checkdrushrc="$(grep '\(/local/drupal/drush_extensions\)' $HOME/.drush/drushrc.php)"
if [ -z "$checkdrushrc" ]
then
  cat << __EOT__ > $HOME/.drush/drushrc.php-update
<?php

\$home = drush_server_home();

\$options['include'][] = \$home . '/local/drupal/drush_extensions';
\$options['config'][] = \$home . '/local/config';
__EOT__
  grep -v '<\?php' $HOME/.drush/drushrc.php >> $HOME/.drush/drushrc.php-update
  mv -f $HOME/.drush/drushrc.php-update $HOME/.drush/drushrc.php
fi

# Get rid of old drushrc5rc.php and drushrc6rc.php symlinks, if they exist.
if [ -f  $HOME/.drush/drush5rc.php ]
then
  # If the old drushrc.php is a symbolic link, then get rid of it.
  drushrctype="`stat --printf='%F' $HOME/.drush/drush5rc.php`"
  if [ "$drushrctype" == "symbolic link" ]
  then
    rm -f $HOME/.drush/drush5rc.php
  fi
fi
if [ -f  $HOME/.drush/drush6rc.php ]
then
  # If the old drushrc.php is a symbolic link, then get rid of it.
  drushrctype="`stat --printf='%F' $HOME/.drush/drush6rc.php`"
  if [ "$drushrctype" == "symbolic link" ]
  then
    rm -f $HOME/.drush/drush6rc.php
  fi
fi

#
# Customize bash settings
#

# If we have not set the location of the UTILISCRIPTS yet,
# write it to $HOME/.bashrc.  Only do this once, in case
# the user might care to change it.
#
# To make this work right with non-login shells (e.g.
# `ssh user@host 'command'` or `drush sql-sync @remote @local`),
# then we need to add the path to the beginning of .bashrc, not the
# end, so that we run before this part:
#   >> # If not running interactively, don't do anything
#   >> [ -z "$PS1" ] && return
chkbashrc=`grep '\(UTILISCRIPTS\)' $HOME/.bashrc`
if [ "X$chkbashrc" = "X" ] ; then
sed -e '/^ *$/,$ d' $HOME/.bashrc > $HOME/.bashrc-update
cat <<- __END__ >> $HOME/.bashrc-update

# Add Utiliscripts to the path and export location environment variables
export UTILISCRIPTS=$UTILISCRIPTS
export SSH_KEY_ARCHIVE=$SSH_KEY_ARCHIVE
[ \$PATH == \${PATH/utiliscripts/} ] && export PATH=\$PATH:\$UTILISCRIPTS

__END__
sed -e '1,/^ *$/ d' $HOME/.bashrc >> $HOME/.bashrc-update
mv -f $HOME/.bashrc-update $HOME/.bashrc
fi

# If we have not set the location of the drush yet,
# write it to $HOME/.bashrc.  Only do this once, in case
# the user might care to change it.
chkbashrc=`grep '\(drush\)' $HOME/.bashrc`
if [ "X$chkbashrc" = "X" ] ; then
sed -e '/^ *$/,$ d' $HOME/.bashrc > $HOME/.bashrc-head
sed -e '1,/^ *$/ d' $HOME/.bashrc > $HOME/.bashrc-body
cp $HOME/.bashrc-head $HOME/.bashrc
cat <<- __END__ >> $HOME/.bashrc

# Add drush to the path
[ \$PATH == \${PATH/drush/} ] && export PATH=\$PATH:\$HOME/local/drupal/drush

__END__
cat $HOME/.bashrc-body >> $HOME/.bashrc
rm $HOME/.bashrc-head
rm $HOME/.bashrc-body
fi

# Rewrite the "Bash Customizations" section
sed -i -e '/Include Bash Customizations/,/End Bash Customizations/ d' $HOME/.bashrc
cat <<- __END__ >> $HOME/.bashrc
# Include Bash Customizations
if [ -d "$HOME/local/sublime-text-2" ] ; then
  [ \$PATH == \${PATH/sublime-text-2/} ] && export PATH=\$PATH:\$HOME/local/sublime-text-2
fi
if [ -f $UTILISCRIPTS/custom-bashrc ]; then
	. $UTILISCRIPTS/custom-bashrc
fi
# End Bash Customizations
__END__


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#  S E T   U P   P R E F E R E N C E S   F O R    V A R I O U S    A P P L I C A T I O N S
#
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if [ -n "$DISPLAY" ] ; then

echo "# Check preferences and configuration..."

#
# Copy sublime license file, if one exists in installdata
#
if [ ! -f $HOME/.config/sublime-text-2/Settings/License.sublime_license ] && [ -f $INSTALLATION_DATA/Licenses/License.sublime_license ] ; then
  mkdir -p $HOME/.config/sublime-text-2/Settings
  cp $INSTALLATION_DATA/Licenses/License.sublime_license $HOME/.config/sublime-text-2/Settings/License.sublime_license
fi

#
# Set up sublime default preferences
#
if [ ! -f $HOME/.config/sublime-text-2/Packages/User/Preferences.sublime-settings ] ; then

mkdir -p $HOME/.config/sublime-text-2/Packages/User

# Set up Sublime default editing preferences to match Drupal php conventions.
# See: http://drupal.org/node/1346890
# Also: http://www.sublimetext.com/forum/viewtopic.php?f=3&t=2704
cat << "__END__" > $HOME/.config/sublime-text-2/Packages/User/Preferences.sublime-settings
{
  "color_scheme": "Packages/Color Scheme - Default/Mac Classic.tmTheme",
  "rulers": [80],
  "tab_size": 2,
  "translate_tabs_to_spaces": true,
  "use_tab_stops": true,
  "trim_automatic_white_space": true,
  "trim_trailing_white_space_on_save": true,
  "ensure_newline_at_eof_on_save": true,
  "fallback_encoding": "UTF-8",
  "default_line_ending": "unix",
  "shift_tab_unindent": true,
  "show_full_path": false,
  "highlight_modified_tabs": true,
  "hot_exit": false,
  "remember_open_files": false,
  "close_windows_when_empty": true,
  // Characters that are considered to separate words
  "word_separators": "./\\()\"'-:,.;<>~!@#%^&*|+=[]{}`~?"
}
__END__

fi

if [ ! -f "$HOME/.config/sublime-text-2/Packages/User/Default (Linux).sublime-keymap" ] || [ "`stat --printf='%s' \"$HOME/.config/sublime-text-2/Packages/User/Default (Linux).sublime-keymap\"`" -lt 10 ] ; then

mkdir -p $HOME/.config/sublime-text-2/Packages/User

cat << "__END__" > "$HOME/.config/sublime-text-2/Packages/User/Default (Linux).sublime-keymap"
[
  /*
   * Nedit key bindings:
   *
   *  Control-g: Find again                   (Also F3 or [Enter])
   *  Control-shift-g: Find previous          (Also shift-F3 or shift-[Enter])
   *  Control-h: Find under                   (Also ctrl-F3)
   *  Control-shift-h: Find under previous    (Also ctrl-shift-F3)
   *  Control-r: replace                      (Was: ctrl-h)
   *  Control-shift-r: Replace next           (Was: shift-ctrl-h)
   *  Control-l: Go to line                   (Was: ctrl-g)
   *  Control-Shift-9: unindent               (Also ctrl-[, or shift-tab w/ selection that contains "\n")
   *  Control-Shift-0: indent                 (Also ctrl-], or tab w/ selection that contains "\n")
   */
  { "keys": ["ctrl+g"], "command": "find_next" },
  { "keys": ["ctrl+shift+g"], "command": "find_prev" },
  { "keys": ["ctrl+h"], "command": "find_under" },
  { "keys": ["ctrl+shift+h"], "command": "find_under_prev" },
  { "keys": ["ctrl+r"], "command": "show_panel", "args": {"panel": "replace"} },
  { "keys": ["ctrl+shift+r"], "command": "replace_next" },
  { "keys": ["ctrl+shift+9"], "command": "unindent" },
  { "keys": ["ctrl+shift+0"], "command": "indent" },
  { "keys": ["ctrl+l"], "command": "show_overlay", "args": {"overlay": "goto", "text": ":"} },

  /*
   *
   * Remapped Sublime Text key bindings:
   *
   *  Control-shift-=: Expand selection to line (Was: ctrl-l)
   */
  { "keys": ["ctrl+shift+="], "command": "expand_selection", "args": {"to": "line"} },
  /*
   * Removed Sublime Text key bindings:
   *
   *  Control-R: goto symbol
   */
  // { "keys": ["ctrl+r"], "command": "show_overlay", "args": {"overlay": "goto", "text": "@"} },
  /*
   * Repeated Sublime Text key bindings:
   *
   *  We list these standard options again so that they will be shown in
   *  place of our customizations in the Sublime menus.  Usually we want
   *  our customization to show up, but here we do not.
   */
  { "keys": ["ctrl+]"], "command": "indent" },
  { "keys": ["ctrl+["], "command": "unindent" }
]
__END__

fi

# Install Sublime Code Intel plugin
#if [ ! -d "$HOME/.config/sublime-text-2/Packages/SublimeCodeIntel" ] ; then
#  git clone git://github.com/Kronuz/SublimeCodeIntel.git "$HOME/.config/sublime-text-2/Packages/SublimeCodeIntel"
#fi

# Install Sublime PhpDoc plugin
if [ ! -d "$HOME/.config/sublime-text-2/Packages/PhpDoc" ] ; then
  git clone git://github.com/SublimeText/PhpDoc.git "$HOME/.config/sublime-text-2/Packages/PhpDoc"
fi

# Install Sublime Drupal snippets
if [ ! -d "$HOME/.config/sublime-text-2/Packages/DrupalSnippets" ] ; then
  git clone git://gitorious.org/sublime-text-snippets/drupal.git "$HOME/.config/sublime-text-2/Packages/DrupalSnippets"
fi

# Install Suplime php lint
if [ ! -d "$HOME/.config/sublime-text-2/Packages/sublimelint" ] ; then
  git clone git://github.com/lunixbochs/sublimelint.git "$HOME/.config/sublime-text-2/Packages/sublimelint"
fi

# Install Sublime zen coding plugin (if mercurial is available)
# See: http://code.google.com/p/zen-coding/downloads/detail?name=ZenCodingCheatSheet.pdf
#hg=`which hg`
#if [ ! -z "$hg" ] && [ ! -d "$HOME/.config/sublime-text-2/Packages/sublime-2-zencoding" ] ; then
#  hg clone https://bitbucket.org/sublimator/sublime-2-zencoding "$HOME/.config/sublime-text-2/Packages/sublime-2-zencoding"
#fi

#
# Set up nedit default preferences
#
mkdir -p $HOME/.nedit
if [ -f $HOME/.nedit/nedit.rc ] ; then

	sed -i $HOME/.nedit/nedit.rc \
		-e 's/^\(nedit.autoWrap: \).*/\1 None/' \
		-e 's/^\(nedit.openInTab: \).*/\1 False/' \
		-e 's/^\(nedit.statisticsLine: \).*/\1 True/' \
		-e 's/^\(nedit.tabDistance: \).*/\1 8/'


else

	cat <<- __END__ > $HOME/.nedit/nedit.rc
	nedit.autoWrap: None
	nedit.openInTab: False
	nedit.statisticsLine: True
	nedit.tabDistance: 8
	__END__

fi
fi

echo "# Check git settings..."

#
# Git stuff
#
# 'git push' should apply to only the current branch,
# not to every branchname that matches on local and remote repositories.
#
git config --global push.default tracking
git config --global url."ssh://git@git.drupal.org/project/".insteadOf d.o:
git config --global url."ssh://git@git.drupal.org/sandbox/".insteadOf sandbox:


# If we can find gconftool-2, AND we have a $DISPLAY, then set up some GUI prefs
g=`which gconftool-2`
d=`which dconf`
if [ -n "$g" ] && [ -n "$d" ] && [ -n "$DISPLAY" ] ; then
  host=`uname -n`
  if [ -d $DESKTOP_BACKGROUND_DIR ] ; then
    #
    # Select and apply a desktop background
    #
    DESKTOP_BACKGROUND=`ls -1 "$DESKTOP_BACKGROUND_DIR" | grep -i "default-" | head -n 1`

    check_host_bg=`ls -1 "$DESKTOP_BACKGROUND_DIR" | grep -i "$host" | head -n 1`
    if [ -n "$check_host_bg" ] ; then
      DESKTOP_BACKGROUND=$DESKTOP_BACKGROUND_DIR/$check_host_bg
    fi
    if [ -f "$DESKTOP_BACKGROUND" ] ; then
      gconftool-2 --type string --set /desktop/gnome/background/picture_filename $DESKTOP_BACKGROUND
      gconftool-2 --type string --set /desktop/gnome/background/picture_options zoom
    fi

    # Maybe set:
    # /apps/gnome-session/options/splash_image == login page image
  fi

  # Remove the top panel
  gsettings set org.gnome.gnome-panel.layout toplevel-id-list "['bottom-panel']"

  # Add the main menu.  The problem is, we need to set the definition for object-0 too.
  # Unfortunately, we can't modify it; see below.
#-org.gnome.gnome-panel.layout object-id-list ['menu-bar', 'indicators', 'show-desktop', 'window-list', 'workspace-switcher']
#+org.gnome.gnome-panel.layout object-id-list ['menu-bar', 'indicators', 'show-desktop', 'window-list', 'workspace-switcher', 'object-0']

  # Desktop names
  gconftool-2 --type int --set /apps/metacity/general/num_workspaces 4
  gconftool-2 --type string --set /apps/metacity/workspace_names/name_1 Dev
  gconftool-2 --type string --set /apps/metacity/workspace_names/name_2 Docs
  gconftool-2 --type string --set /apps/metacity/workspace_names/name_3 VM
  gconftool-2 --type string --set /apps/metacity/workspace_names/name_4 Web
  dconf write /org/gnome/gnome-panel/layout/objects/workspace-switcher/instance-config/num-rows 2
  dconf write /org/gnome/gnome-panel/layout/objects/workspace-switcher/instance-config/display-workspace-names true
  dconf write /org/gnome/gnome-panel/layout/objects/workspace-switcher/instance-config/display-all-workspaces true

  # Some panel changes will require:
  # killall -HUP gnome-panel

  # For panel settings, see:
  # dconf dump /org/gnome/gnome-panel/layout/

  # Documentation on gconf tool is here:
  # http://library.gnome.org/admin/system-admin-guide/stable/gconf-8.html.en

  # To dump all gconf variables:
  #
  #   gconftool-2 -R /
  #
  # To dump all dconf variables:
  #
  #   gsettings list-recursively
  #
  # Dump the output of both of these commands into two separate files;
  # then, change the settings you wish via the GUI, dump the settings again,
  # and diff against the old output.  If you do not see all of the information
  # from the settings that you changed, it means that preference is stored
  # in a schemaless key in dconf.  There is no really good way around this
  # problem.  All panel items, the number of rows in the workspace switcher,
  # and the settings to show workspace names are all examples of variables that
  # cannot be set.
  #
  # More info here:
  #
  # http://askubuntu.com/questions/126300/how-do-i-configure-the-gnome-panel-from-a-script

fi

exit 0

